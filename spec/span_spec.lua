local Span
Span = require("modal.types").Span
local Fraction
Fraction = require("modal.fraction").Fraction
return describe("Span", function()
  describe("wholeCycle", function()
    return it("should return the large cycle that contains the span", function()
      local f1 = Fraction(1, 2)
      local actual = Span:wholeCycle(f1)
      local expected = Span(0, 1)
      assert.are.same(expected, actual)
      local f2 = Fraction(3, 2)
      actual = Span:wholeCycle(f2)
      expected = Span(1, 2)
      return assert.are.same(expected, actual)
    end)
  end)
  describe("cyclePos", function()
    return it("should return the position within the cycle as a proper fraction", function()
      local f1 = Fraction(7, 2)
      local actual = Span:cyclePos(f1)
      local expected = Fraction(1, 2)
      return assert.are.same(expected, actual)
    end)
  end)
  describe("new", function()
    it("should create with defaults", function()
      local t = Span()
      assert.are.same(Fraction(1), t._begin)
      return assert.are.same(Fraction(1), t._end)
    end)
    it("should create with args", function()
      local t = Span(3, 4)
      assert.are.same(Fraction(3), t._begin)
      return assert.are.same(Fraction(4), t._end)
    end)
    return it("should promote numbers to fractions", function()
      local t = Span(0.5, 0.75)
      assert.are.same(Fraction(1, 2), t._begin)
      return assert.are.same(Fraction(3, 4), t._end)
    end)
  end)
  describe("spanCycles", function()
    it("should break multi cycle span into pieces", function()
      local t = Span(3 / 4, 7 / 2)
      local spans = t:spanCycles()
      assert.are.same(4, #spans)
      assert.are.same(Fraction(3, 4), spans[1]._begin)
      assert.are.same(Fraction(1, 1), spans[1]._end)
      assert.are.same(Fraction(1, 1), spans[2]._begin)
      assert.are.same(Fraction(2, 1), spans[2]._end)
      assert.are.same(Fraction(2, 1), spans[3]._begin)
      assert.are.same(Fraction(3, 1), spans[3]._end)
      assert.are.same(Fraction(3, 1), spans[4]._begin)
      return assert.are.same(Fraction(7, 2), spans[4]._end)
    end)
    return it("should preserve subcycle length spans", function()
      local t = Span(1 / 16, 1)
      local spans = t:spanCycles()
      assert.are.same(1, #spans)
      assert.are.same(Fraction(1, 16), spans[1]._begin)
      return assert.are.same(Fraction(1, 1), spans[1]._end)
    end)
  end)
  describe("duration", function()
    return it("should return duration of the span", function()
      local t = Span(3 / 4, 7 / 2)
      assert.are.same(Fraction(11, 4), t:duration())
      t = Span(6 / 7, 10 / 11)
      return assert.are.same(Fraction(4, 77), t:duration())
    end)
  end)
  describe("midpoint", function()
    return it("should return the middle point between span begin and end", function()
      local t = Span(0, 1)
      assert.are.same(Fraction(1, 2), t:midpoint())
      t = Span(7 / 11, 5 / 4)
      return assert.are.same(Fraction(83, 88), t:midpoint())
    end)
  end)
  describe("cycleSpan", function()
    return it("should return the span as if it started in cycle 0", function()
      local t = Span(5 / 4, 11 / 4)
      return assert.are.same(Span(1 / 4, 7 / 4), t:cycleSpan())
    end)
  end)
  describe("equals", function()
    return it("should compare properties", function()
      local t1 = Span(1 / 2, 5 / 4)
      local t2 = Span(1 / 2, 5 / 4)
      assert.are.same(t1, t2)
      t1 = Span(4 / 8, 5 / 4)
      t2 = Span(1 / 2, 10 / 8)
      return assert.are.same(t1, t2)
    end)
  end)
  describe("withTime", function()
    return it("should return new span with modified begin time", function()
      local add1
      add1 = function(frac)
        return frac + Fraction(1)
      end
      local t = Span(1 / 2, 5 / 6)
      local actual = t:withTime(add1)
      local expected = Span(3 / 2, 11 / 6)
      return assert.are.same(expected, actual)
    end)
  end)
  describe("withEnd", function()
    return it("should return new span with modified end time", function()
      local add1
      add1 = function(frac)
        return frac + Fraction(1)
      end
      local t = Span(1 / 2, 5 / 6)
      local actual = t:withEnd(add1)
      local expected = Span(1 / 2, 11 / 6)
      return assert.are.same(expected, actual)
    end)
  end)
  describe("intersection", function()
    return it("should return the common timespan between two spans", function()
      local ts1 = Span(1 / 2, 5 / 4)
      local ts2 = Span(2 / 3, 2 / 2)
      local expected = Span(2 / 3, 2 / 2)
      assert.are.same(Span(2 / 3, 2 / 2), ts1:sect(ts2))
      assert.are.same(Span(2 / 3, 2 / 2), ts2:sect(ts1))
      ts1 = Span(1 / 2, 5 / 4)
      ts2 = Span(5 / 4, 7 / 4)
      assert.is_nil(ts1:sect(ts2))
      return assert.is_nil(ts2:sect(ts1))
    end)
  end)
  return describe("intersection_e", function()
    return it("should return the common timespan between two spans", function()
      local ts1 = Span(1 / 2, 5 / 4)
      local ts2 = Span(2 / 3, 2 / 2)
      local expected = Span(2 / 3, 2 / 2)
      assert.are.same(Span(2 / 3, 2 / 2), ts1:sect_e(ts2))
      assert.are.same(Span(2 / 3, 2 / 2), ts2:sect_e(ts1))
      ts1 = Span(1 / 2, 5 / 4)
      ts2 = Span(5 / 4, 7 / 4)
      assert.has_error((function()
        return ts1:sect_e(ts2)
      end))
      return assert.has_error((function()
        return ts2:sect_e(ts1)
      end))
    end)
  end)
end)
