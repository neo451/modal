local M = require "modal"
local maxi = require "modal.maxi"
local describe = require("busted").describe
local it = require("busted").it
local assert = require("busted").assert

assert.pat = function(a, b)
   assert.same(a(0, 1), b(0, 1))
end
local to_f, to_str = maxi(M, true)

local eval = function(str)
   return M.mini(str)()
end

local eval_top = function(str)
   return to_f(str)()
end

describe("symb", function()
   it("should parse steps to lua String or Id", function()
      local hello
      assert.same("hello", eval "hello")
      assert.same(hello, eval "^hello")
   end)
   it("should parse steps to lua String or Id", function()
      assert.same(42, eval "42")
   end)
end)

describe("set", function()
   it("should parse set to lua var set in only top level????", function()
      assert.same("a = 1; ", to_str [[ a = 1 ]])
   end)
   -- it("should parse set a func call to var", function()
   --    assert.same("a = fast(pure2(2), pure2(1)); ", to_str " a = $ fast 2 1 ")
   -- end)
   -- it("should parse set a sexp to var", function()
   --    assert.same("a = fast(2, 1); ", to_str " a = (fast 2 1) ")
   -- end)
   -- it("should parse set a mini-notation to var", function()
   --    assert.same([[a = fastcat({pure("bd"),pure("sd")}); ]], to_str "a = [bd sd]")
   -- end)
end)

describe("step", function()
   it("numbers", function()
      assert.same(-1, eval "-1")
   end)
end)

describe("slice", function()
   it("should parse mini slice as a first class", function()
      assert.same("bd", eval "bd")
   end)
end)

describe("subcycle", function()
   it("should parse mini subcycle as a first class", function()
      assert.pat(M.fastcat { "bd" }, eval "[bd]")
      assert.pat(M.fastcat { "bd", "sd" }, eval "[bd sd]")
   end)
end)

describe("stack", function()
   it("should parse mini stack as a first class", function()
      assert.pat(M.stack { M.pure "bd", M.pure "sd" }, eval "[bd, sd]")
      assert.pat(M.stack { M.fastcat { "bd", "bd" }, M.fastcat { "sd", "sd" } }, eval "[bd bd, sd sd]")
   end)
end)

describe("slow_seq", function()
   it("should parse mini slow_seq as a first class", function()
      assert.pat(M.slowcat { "bd" }, eval "<bd>")
      assert.pat(M.slowcat { "bd", "sd" }, eval "<bd sd>")
      assert.pat(M.slowcat { 0, 1, 2, 3, 4 }, eval "<0 .. 4>")
   end)
end)

describe("polymeter", function()
   it("should parse mini polymeter as a first class", function()
      assert.pat(M.fastcat { "bd", "sd", "hh" }, eval "{bd sd hh}")
      assert.pat(M.fastcat { "bd", "sd", "hh" }, eval "{bd sd hh}%3")
      assert.pat(M.fastcat { "bd", "sd" }, eval "{bd sd hh}%2")
      assert.pat(M.stack { M.fastcat { "bd", "sd" }, M.fastcat { 1, 2 } }, eval "{bd sd hh, 1 2 3 4}%2")
   end)
end)

describe("choose", function()
   it("should parse mini choose as first class", function()
      assert.pat(M.randcat(M.pure "bd", M.pure "sd", M.pure "cp"), eval "[bd | sd | cp]")
      assert.pat(M.randcat(M.fastcat { "bd", "sd" }, M.pure "sd", M.pure "cp"), eval "[bd sd | sd | cp]")
   end)
end)

describe("ops", function()
   it("should parse mini ops as a first class", function()
      assert.pat(M.fast(2, "bd"), eval "bd*2")
      assert.pat(M.euclidRot(3, 8, 0, "bd"), eval "bd(3,8)")
      assert.pat(M.degradeBy(0.5, "bd"), eval("bd?", "degradeBy"))
      assert.pat(M.fastcat { "bd", "bd", "sd" }, eval "[bd! sd]")
      assert.pat(M.pure { 0.3, 0.5, 2 }, eval "0.3:0.5:2")
   end)
   it("weight", function()
      assert.pat(M.timecat { 2, "bd", 1, "sd" }, eval "[bd@2 sd]")
      assert.pat(M.timecat { 3, "bd", 2, "sd" }, eval "[bd __ sd _]")
      assert.pat(M.arrange { 2, "bd", 1, "sd" }, eval "<bd@2 sd>")
   end)
end)

describe("tidal ops", function()
   it("should parse tidal ops as a first class", function()
      assert.pat(M.note(3), eval_top [[note 2 +| note 1]])
      assert.pat(M.pure { s = "bd", room = "0.2" }, eval_top [[s bd |> room 0.2]])
      assert.pat(M.pure { s = "bd", room = "0.2" }, eval_top [[s bd >|| room 0.2]])
   end)
end)

describe("list(p)", function()
   it("should parse sexp as a first class", function()
      assert.same(3, eval "(+ 1 2)")
      assert.same(-1, eval "(- 1 2)")
   end)
   it("should parse sexp func call as a first class", function()
      assert.pat(M.fast(1, 2), eval "(fast 1 2)")
      assert.pat(M.fast(1, M.pure(2)), eval "(fast 1 (pure 2))")
   end)
   it("should parse nested function calls", function()
      assert.same(M.fast(2, 1)(1, 2), eval "((fast 2 1) 1 2)")
   end)
   it("should do prefix operator", function()
      assert.same(2, eval "(+ 1 1)")
   end)
   it("should do currying for arithmetic", function()
      assert.same(2, eval "((+ 1) 1)")
      assert.same(2, eval "((+) 1 1)")
   end)
   -- TODO: curry for all functions
end)
